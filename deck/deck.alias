<drac2>
args = &ARGS&
N,ZERO_SPACE,TRIPLE_BACK_TICKS = "\n","\u200c","`"+"`"+"`"
VARNAME = "custom_decks"
COMBAT_EFFECT_NAME,COMBAT_DECKLOAD_NAME,COMBAT_DRAWPILE_NAME,COMBAT_DISCARDPILE_NAME,COMBAT_EXHAUSTPILE_NAME = "Playing Cards","init_deckload","shared_drawpile","shared_discardpile","shared_exhaustpile"
DEFAULT_DECKS = ["f4b75892-9488-413e-88c9-20b8183541c6"]
FOOTER_STRING = "!deck | v3.1.0 | Lovingly made by @""Love-chan#5252"

c = combat()
combat_hand_name = name + "_COMBATHAND"
character_pic = image

deckvars = [] + DEFAULT_DECKS

using(
    json="c0a7533c-6376-41e9-8c03-18f7742668e5",
    numbertool="8f4557ba-39bc-4408-be36-d3c68b6544cf",

    ## Pronouns module by Lathaon#6649
    pronouns="2c4012a3-accd-4fcf-a5e2-30bb51800c4e"
    )

character().set_cvar_nx("deck_settings", dump_yaml({"auto_shuffle":False}))
autoshuffle_on_reset = load_yaml(character().get_cvar("deck_settings"))["auto_shuffle"]

## Determines whether the alias will use the shared initiative deck or not.
## use_shared_deck also determines where the card setting functions will place their data (cvar or metadata)
use_shared_deck = False
if c:
    if c.me:
        if c.me.get_effect(COMBAT_EFFECT_NAME):
            use_shared_deck = True
            ## If not all of them are true, use_shared_deck stays False.

if use_shared_deck:
    possessive = "the"
else:
    possessive = pronouns.their()    

their = pronouns.their()
they = pronouns.they()

def set_deckload(new_deckload):
    if not use_shared_deck:
        character().set_cvar("deckload", dump_yaml(new_deckload))
    else:
        c.set_metadata(COMBAT_DECKLOAD_NAME, dump_yaml(new_deckload))

def set_drawpile(new_drawpile):
    if not use_shared_deck:
        character().set_cvar("drawpile", dump_json(new_drawpile))
    else:
        c.set_metadata(COMBAT_DRAWPILE_NAME, dump_json(new_drawpile))

def set_cardhand(new_hand):
    if not use_shared_deck:
        character().set_cvar("cardhand", dump_json(new_hand))
    else:
        c.set_metadata(combat_hand_name, dump_json(new_hand))

def set_discardpile(new_discardpile):
    if not use_shared_deck:
        character().set_cvar("discardpile", dump_json(new_discardpile))
    else:
        c.set_metadata(COMBAT_DISCARDPILE_NAME, dump_json(new_discardpile))

def set_exhaustpile(new_exhaustpile):
    if not use_shared_deck:
        character().set_cvar("exhaustpile", dump_json(new_exhaustpile))
    else:
        c.set_metadata(COMBAT_EXHAUSTPILE_NAME, dump_json(new_exhaustpile))

if not use_shared_deck:
    ## Sets deckload and deckLoaded information to personal settings
    if character().get_cvar("deckload"):
        ## deckload is a config file that stores the name of the deck being used and the address of the GVAR containing that deck's information
        deckload = load_yaml(character().get_cvar("deckload"))  #accesses the config cvar
        deckLoaded = (load_json(get_gvar(deckload["gvar"])))[deckload["deckname"]]  #loads the saved deck from the GVAR containing it
    else:
        ## Loads the first default deck of the first gvar if no deckload settings exist yet
        default_decks_loaded = load_json(get_gvar(DEFAULT_DECKS[0]))
        default_deck_key = list(default_decks_loaded.keys())[0]
        deckload = {"deckname":default_deck_key, "gvar":DEFAULT_DECKS[0]}
        set_deckload(deckload)
        deckLoaded = default_decks_loaded[default_deck_key]
else:
    ## Sets deckload and deckLoaded information to the shared combat settings.
    deckload = load_yaml(c.get_metadata(COMBAT_DECKLOAD_NAME))
    deckLoaded = (load_json(get_gvar(deckload["gvar"])))[deckload["deckname"]]

def fresh_deck():
    return list(deckLoaded.keys())

if not use_shared_deck:
## Loads cards, drawpile, hand, discardpile according to personal settings.

    ## Gets the drawpile, which is a list of card keys, or sets it to the base, unshuffled loaded deck if none exists.
    if (drawpile := character().get_cvar("drawpile")):
        drawpile = load_json(drawpile)
    else:
        drawpile = fresh_deck()

    ## Gets the cardhand, which is a list of card keys, or sets it to an empty list if none exists.
    if (cardhand := character().get_cvar("cardhand")): 
        cardhand = load_json(cardhand)
    else:
        cardhand = []

    ## Gets the discardpile, which is a list of card keys, or sets it to an empty list if none exists.
    if (discardpile := character().get_cvar("discardpile")):
        discardpile = load_json(discardpile)
    else:
        discardpile = []

    ## Gets the exhaustpile, which is a list of card keys, or sets it to an empty list if none exists.
    if (exhaustpile := character().get_cvar("exhaustpile")):
        exhaustpile = load_json(exhaustpile)
    else:
        exhaustpile = []
    
else:
## Loads cards, drawpile, hand, discardpile according to shared combat settings.

    ## Sets drawpile according to shared combat settings.
    drawpile = load_json(c.get_metadata(COMBAT_DRAWPILE_NAME))

    ## Sets cardhand according to shared combat settings.
    cardhand = load_json(c.get_metadata(combat_hand_name))

    ## Sets discardpile according to shared combat settings.
    discardpile = load_json(c.get_metadata(COMBAT_DISCARDPILE_NAME))

    ## Sets exhaustpile according to shared combat settings.
    exhaustpile = load_json(c.get_metadata(COMBAT_EXHAUSTPILE_NAME))

def unpack_stargs(args):
## For use compiling all the *args in a function
## The inputs may be a mix of lists and other objects, so it will take all the 
## objects inside the lists and add them to a single list of the other objects.
    out = []
    for i in args:
        if typeof(i) == "SafeList":
            out += i
        else:
            out.append(i)
    return out

def shuffle(cards: list):
    ## cards = input_cards.copy()  #?????
    shuffled = []
    for i in range(len(cards)):
        random_card = cards.pop(randint(0, len(cards)))
        shuffled.append(random_card)
    return shuffled

def draw(cards: list, cards_drawn=1):
    drawn = []
    cards_drawn = min(max(1, cards_drawn), len(cards))
    for i in range(cards_drawn):
        drawn.append(cards.pop(0))
    set_cardhand(drawn + cardhand)
    set_drawpile(drawpile)
    return drawn

def discard(*input_cards, discard_from: list=cardhand):
## If discarding from somewhere other than cardhand, you must save/set it manually.
    cards = unpack_stargs(input_cards)
    discarded = []
    for card in cards:
        if (discard_card := ([(i, v) for i, v in enumerate(discard_from) if card.lower() in v.lower()]+[None])[0]):
            discarded.append(discard_from.pop(discard_card[0]))

    set_discardpile(discarded + discardpile)
    if discard_from == cardhand:
        set_cardhand(cardhand)

    return discarded

def exhaust(*input_cards, exhaust_from: list=cardhand):
## If exhausting from somewhere other than cardhand, you must save/set it manually.
    cards = unpack_stargs(input_cards)
    exhausted = []
    for card in cards:
        if (exhaust_card := ([(i, v) for i, v in enumerate(exhaust_from) if card.lower() in v.lower()]+[None])[0]):
            exhausted.append(exhaust_from.pop(exhaust_card[0]))

    set_exhaustpile(exhausted + exhaustpile)
    if exhaust_from == cardhand:
        set_cardhand(cardhand)

    return exhausted

def reset_deck():
    if autoshuffle_on_reset:
        reset_pile = shuffle(fresh_deck())
        set_drawpile(reset_pile)
    else:
        reset_pile = fresh_deck()
        set_drawpile(reset_pile)

    set_cardhand([])
    set_discardpile([])
    set_exhaustpile([])

    for i in range(len(cardhand)):
        cardhand.pop(0)
    for i in range(len(discardpile)):
        discardpile.pop(0)
    for i in range(len(exhaustpile)):
        exhaustpile.pop(0)

    return reset_pile


### Some utilities for constructing the embeds used in the alias outputs

def get_card_display_names(cards: list):
    return [deckLoaded[i]["name"] for i in cards]

def fieldsplit(list_to_split: list, fieldhead: str=ZERO_SPACE, splitby: int=5, inline: bool=True):
    if list_to_split:
        split_lists = []
        for i in range((len(list_to_split) + splitby - 1)//splitby):
            ## With default input, appends list_to_split[0:5], then list_to_split[5:10], list_to_split[10:15] and so on
            split_lists.append(
                list_to_split[i*splitby:(i + 1)*splitby]
            )
        out_fields = []
        for i in split_lists:
            out_fields.append(
                f"""-f "{fieldhead}|{N.join(i)}{'|inline' if inline else ''}" """
            )
        return " ".join(out_fields)
    else:
        return ""

def cutstring(inp: str, cut: int):
    if len(inp) > cut:
        return inp[:cut] + "..."
    else:
        return inp

def effect_preview(effect: SimpleEffect):
## Prints a quick preview of an effect as shown by a char's name in init on their turn
  if effect.desc:
    return str(effect).replace(str(effect.desc),"")[:-5]
  else:
    return str(effect)

def current_cards_str(drawpile=drawpile, cardhand=cardhand, discardpile=discardpile, exhaustpile=exhaustpile, shared=use_shared_deck):
    drawpilelen = len(drawpile)
    handlen = len(cardhand)
    discardlen = len(discardpile)
    exhaustlen = len(exhaustpile)

    exhaustplural = f"{'cards' if exhaustlen != 1 else 'card'}"
    sharetext = f"{' shared ' if shared else ' '}"
    
    return ("*"
            + drawpilelen
            + f" {'cards' if drawpilelen != 1 else 'card'} remaining in{sharetext}draw pile."
            + "*" + N + "*"
            + handlen
            + f" {'cards' if handlen != 1 else 'card'} in hand."
            + "*" + N + "*"
            + discardlen
            + f" {'cards' if discardlen != 1 else 'card'} in{sharetext}discard pile."
            + "*"
            + (f""" {N + "*" + exhaustlen + sharetext + exhaustplural + " exhausted.*" if (character().levels.get("Cardistor")>=1 or exhaustlen>0) else ""}""")
    )

def help_embed():
    return ("embed "
            + f""" -title "{name} needs some help with `!deck`!" """
            + " -desc "
            + '\"'
            + "Use `!deck draw` to draw 1 card, or `!deck draw [#]` to draw # amount of cards!"
            + N + N
            + "Use `!deck hand` to check the contents of your hand!"
            + N + N
            + "Use `!deck discard` to move all of the cards from your hand to your discard pile!"
            + N + N
            + "Use `!deck discard [card names]` to select and discard specific cards."
            + N + N
            + "Use `!deck reset` to completely reset your drawpile to the currently selected deck. In shared card initiative, everyone must discard their cards first, or else it's called cheating!"
            + N + f"*Automatic shuffling on reset: `{autoshuffle_on_reset}`*"
            + N + N
            + "Use `!deck shuffle` to shuffle your draw pile."
            + N + N
            + "Use `!deck reshuffle` or `!deck shuffle discard` to shuffle your discard pile into your draw pile."
            + N + N
            + "Use `!deck select` to select a different deck! Read the options carefully!"
            + N + N
            + "Use `!deck init` to check the current state of the shared deck initiative. Characters in shared deck initiative share the same draw pile, discard pile, and exhaust pile."
            + N + N
            + "Use `!deck init join` to start sharing your cards with other players! (The first character to join sets the initiative's card piles to their own.)"
            + '\"'
            + f""" -footer "{FOOTER_STRING}" -thumb "{character_pic}" """
    )

## THIS IS THE HELP EMBED. IT COMES BEFORE ALL OF THE OTHER EMBEDS BECAUSE THEY CHECK FOR args[0]
## AND IT WILL ERROR IF IT TRIES TO CHECK THAT AND THERE ARE NO ARGS.
if not args or "help" in args:
    return help_embed()

if "draw" == args[0]:
    
    cardhand_display_fields = fieldsplit(get_card_display_names(cardhand), fieldhead="**Cards Already In Hand:**")
    
    if len(drawpile) == 0:
        return f"""embed -title "{name} has no cards left to draw!" -desc "{current_cards_str()}" {cardhand_display_fields} -footer "{FOOTER_STRING}" -thumb "{character_pic}" """

    if len(args) >= 2:
        if numbertool.isint(args[1]):
            cards_drawn = max(
                1, 
                min(int(args[1]), len(drawpile))
                )
            draw_err = ""
        else:
            if (bad_args := args[1].replace('"', '\\"')):
                draw_err = f"""-f "Oops!|You inputted `{bad_args}` instead of how many cards you wanted to draw! Only whole, positive numbers will be accepted! Only 1 card will be drawn otherwise." """
            else:
                draw_err = ""
            cards_drawn = 1
    
    else:
        draw_err = ""
        cards_drawn = 1


    drawn = draw(drawpile, cards_drawn)
    cardhand = (drawn + cardhand)
    
    card_str = current_cards_str()

    drawn_display_fields = fieldsplit(get_card_display_names(drawn), fieldhead="**Drawn Cards:**")
    
    return f"""embed -title "{name} draws {cards_drawn} {"card" if cards_drawn==1 else "cards"} from {possessive} draw pile and adds {"it" if cards_drawn==1 else "them"} to {their} hand!" -desc "*Drawn from {deckload["deckname"]}.*{N + N + card_str}" {drawn_display_fields} {cardhand_display_fields} {draw_err} -footer "{FOOTER_STRING}" -thumb "{character_pic}" """
## """
## Use `!deck draw` to draw 1 card, or `!deck draw [#]` to draw # amount of cards!
## """

if "hand" == args[0]:

    card_str = current_cards_str()

    hand_display_fields = fieldsplit(get_card_display_names(cardhand), fieldhead="Cards In Hand:")


    handphrases = load_json(
                    f"""["checks", "takes a peek at", "browses", "sifts through", "couldn't memorize",
                    "shows the table", "cheats at", "remembers {they} can look at", "needs a card from", "can't believe",
                    "forgor", "forgot", "is tempted to savescum", "deliberates", "reconsiders",
                    "wants to pull {their} hair out over", "considers bluffing with", "scries", "indexes",
                    "processes", "comes to terms with", "makes enemies with", "wants to bet on",
                    "might lose everything with", "makes goo-goo eyes at", "isn't too proud of",
                    "feasts {their} eyes on", "generates endless synonyms with", "swears at",
                    "FINALLY realizes that the title of this embed is as random as the minecraft loading screen with",
                    "rolled a nat 20 with", "rolled a nat 1 with", "might have a good", "messes with",
                    "fidgets with", "worries over", "reads fine literature with", "is bleeding",
                    "wants to DM Love-chan#5252 with a suggestion for the text that appears when {they} {pronouns.verb('checks', 'check')}",
                    "verbs", "[adjective] [verb]'s", "has a sudden compulsion to eat", "wants to throw out",
                    "can't tell the difference between garbage and", "sobs at floor 1 jaw worm with",
                    "is praying to snecko as {they} {pronouns.verb('sobs', 'sob')} at", "husks at", "<:husk:994063369655042069>'s at"]"""
                )
    handphrase = randchoice(handphrases)

    return f"""embed -title "{name} {handphrase} {their} hand!" -desc "{card_str}" {hand_display_fields} """
## """
## Use `!deck hand` to check the contents of your hand!
## """

if "discard" == args[0]:
    if len(args) >= 2:
        ## Discards only the specified cards if specified cards are provided.
        ## Function also sets the hand post-discarding.

        ## GETS THE CARDS' KEYS FROM THEIR DISPLAY NAMES
        ## BECAUSE THE USER CANNOT SEE THE KEYS/IDS.
        ## DON'T TOUCH THIS.
        ## DON'T TOUCH THIS.
        key_tuples = [(deckLoaded[i]["name"], i) for i in deckLoaded]  #DON'T TOUCH THIS.
        valid_card_keys = []  #DON'T TOUCH THIS.
        for user_substring in args[1:]:  #DON'T TOUCH THIS.
            temp_candidate_keys = []  #DON'T TOUCH THIS.
            for display_name, card_key in key_tuples:  #DON'T TOUCH THIS.
                if user_substring.lower() in display_name.lower():  #DON'T TOUCH THIS.
                    temp_candidate_keys.append(card_key)  #DON'T TOUCH THIS.
            nondupe_keys = []  #DON'T TOUCH THIS.
            for i in temp_candidate_keys:  #DON'T TOUCH THIS.
                if (i in cardhand) and (not (str(i) in valid_card_keys)):  #DON'T TOUCH THIS.
                    nondupe_keys.append(i)  #DON'T TOUCH THIS.
            if nondupe_keys:  #DON'T TOUCH THIS.
                valid_card_keys.append(nondupe_keys[0])  #DON'T TOUCH THIS.
        ## DON'T TOUCH THIS.
        ## DON'T TOUCH THIS.

        discarded = discard(valid_card_keys) 

        ## Gets the names of the discarded cards and italicizes them for display.
        discarded = ["*" + i + "*" for i in get_card_display_names(discarded)]
        ## Turns the fetched, italicized names into fields for the output.
        discard_display_fields = fieldsplit(discarded, fieldhead="**Discarded Cards:**")

        discardpile = (discarded + discardpile)

        ## Fetches names and creates fields to show the remaining cardhand for display.
        cardhand_display_fields = fieldsplit(get_card_display_names(cardhand), fieldhead="**Cards In Hand:**")

        return f"""embed -title "{name} {'discards' if discarded else 'tries to discard'}!" -desc "{current_cards_str()}{N+N+'`No matches found!`' if not discarded else ''}" {cardhand_display_fields} {discard_display_fields} -footer "{FOOTER_STRING}" -thumb "{character_pic}" """

    else:
        ## Discards the entire hand.
        discarded = discard(cardhand)
        discardpile = (discarded + discardpile)
        discarded = ["*" + i + "*" for i in get_card_display_names(discarded)]
        discard_display_fields = fieldsplit(discarded, fieldhead="**Discarded Cards:**")
        return f"""embed -title "{name} discards thier hand!" -desc "*Hand placed on top of discard pile.*{N+N+current_cards_str()}" {discard_display_fields} -footer "{FOOTER_STRING}" -thumb "{character_pic}" """
## """
## Use `!deck discard` to move all of the cards from your hand to your discard pile!
## {N+N}
## Use `!deck discard [card names]` to select and discard specific cards.
## """

if "reset" == args[0]:
    if len(args) >= 2:
        if autoshuffle_on_reset:
            new_autoshuffle = False
        else:
            new_autoshuffle = True
        character().set_cvar("deck_settings", dump_yaml({"auto_shuffle":new_autoshuffle}))
        return f"""embed -title "{name} toggles automatic shuffling on deck reset!" -desc "Toggle automatic shuffling-on-reset with `!deck reset automatic`!{N}*Automatic shuffling on reset: `{new_autoshuffle}`*" -footer "{FOOTER_STRING}" -thumb "{character_pic}" """
    
    drawpile = reset_deck()
    
    if autoshuffle_on_reset:
        shuffle_msg = "*Drawpile automatically shuffled!*"
    else: 
        shuffle_msg = f"*Remember to shuffle! (`!deck shuffle`)*{N}*Toggle automatic shuffling-on-reset with `!deck reset automatic`!*"
    
    card_str = current_cards_str()

    return f"""embed -title "{name} resets {possessive} cards!" -desc "*Draw pile reset to `{deckload["deckname"]}`.*{N+N+card_str+N+N+shuffle_msg}" -footer "{FOOTER_STRING}" -thumb "{character_pic}" """
## """
## Use `!deck reset` to completely reset your drawpile to the currently selected deck. In shared card initiative, everyone must discard their cards first, or else it's called cheating!
## {N}Automatic shuffling on reset: `{autoshuffle_on_reset}`
## """

def reshuffle():
    shuffled = shuffle(drawpile + discardpile)
    set_drawpile(shuffled)
    set_discardpile([])
    card_str = current_cards_str(drawpile=shuffled, discardpile = [])
    return f"""embed -title "{name} shuffles {possessive} discard pile into {possessive} draw pile!" -desc "*Discard pile shuffled into draw pile.*{N+card_str}" -footer "{FOOTER_STRING}" -thumb "{character_pic}" """ 

if "reshuffle" == args[0]:
    return reshuffle()

if "shuffle" == args[0]:
    if len(args) >= 2:
        if args[1] in "discarded":
            return reshuffle()
    shuffled = shuffle(cards=drawpile)
    drawpile = shuffled
    set_drawpile(shuffled)
    return f"""embed -title "{name} shuffles {possessive} draw pile!" -desc "*Drawpile shuffled still containing previous cards.*{N+N}Use `!deck reset` to completely reset your cards.{N+N}Use `!deck shuffle discard` or `!deck reshuffle` to shuffle your discard pile into your draw pile.{N+N+current_cards_str()}" -footer "{FOOTER_STRING}" -thumb "{character_pic}" """
## """
## Use `!deck shuffle` to shuffle your draw pile.
## {N+N}
## Use `!deck reshuffle` or `!deck shuffle discard` to shuffle your discard pile into your draw pile.
## """

if "select" == args[0] or "load" == args[0]:
    detailedsources = []
    [[detailedsources.append(f"{deckname} _(`{gvar}` in __alias default decks__)_") for deckname in load_json(get_gvar(gvar))] for gvar in DEFAULT_DECKS]
   
    if get_svar(VARNAME):
        svargvars = [gvar for gvar in load_json(get_svar(VARNAME))]
        deckvars = deckvars + svargvars
        [[detailedsources.append(f"{deckname} _(`{gvar}` in __svar__)_") for deckname in load_json(get_gvar(gvar))] for gvar in svargvars]
    
    if get_uvar(VARNAME):
        uvargvars = [gvar for gvar in load_json(get_uvar(VARNAME))]
        deckvars = deckvars + uvargvars
        [[detailedsources.append(f"{deckname} _(`{gvar}` in __uvar__)_") for deckname in load_json(get_gvar(gvar))] for gvar in uvargvars]
    
    iteration = 0
    sourceselect = {}
    for gvar in deckvars: 
        for deckname in load_json(get_gvar(gvar)):
            iteration = iteration + 1
            sourceselect.update({str(iteration):{"deckname":deckname, "gvar":gvar}})
    
    sourcedisplay = [str("`" + (i+1) + "`: " + v) for i, v in enumerate(detailedsources)]

    if len(args) >= 2:
        if str(args[1]) in sourceselect:
            userselection = sourceselect[str(args[1])]
            set_deckload(userselection)

            deckLoaded = (load_json(get_gvar(userselection["gvar"])))[userselection["deckname"]]  #sets the selected deck as deckLoaded for use in reset_deck()
            drawpile = reset_deck()  #calls on fresh_deck() which calls on deckLoaded
            ## ^^ sets drawpile for use in current_cards_str()

            if autoshuffle_on_reset:
                shuffle_msg = "*Drawpile automatically shuffled!*"
            else: 
                shuffle_msg = f"*Remember to shuffle! (`!deck shuffle`)*{N}*Toggle automatic shuffling-on-reset with `!deck reset automatic`!*"

            if use_shared_deck:
                personal_or_shared_deckload = '**Shared \\"deckload\\" Set To:**'
                personal_or_shared_deckpreview = "**Sample of Selected Deck:**"
                personal_or_shared_title = f"{name} sets {userselection['deckname']} as the new shared initiative deck!"
            else:
                personal_or_shared_deckload = '**Cvar \\"deckload\\" Set To:**'
                personal_or_shared_deckpreview = "**Sample of New Shared Deck:**"
                personal_or_shared_title = f"{name} sets {userselection['deckname']} as {their} active deck!"

            deckloadpreview = (personal_or_shared_deckload
                                + TRIPLE_BACK_TICKS
                                + "yaml"
                                + N
                                + dump_yaml(userselection)
                                + TRIPLE_BACK_TICKS)
            
            get_deck = (load_json(get_gvar(userselection["gvar"])))[userselection["deckname"]]

            deckpreviewtext = (personal_or_shared_deckpreview
                               + TRIPLE_BACK_TICKS
                               + 'json'
                               + N
                               + (cutstring(
                                    json.format_json(get_deck),
                                    400)
                                 ).replace('"', '\\"')
                               + TRIPLE_BACK_TICKS)

            card_str = current_cards_str()

            return f"""embed -title "{personal_or_shared_title}" -desc "*Draw pile set to `{userselection["deckname"]}`.*{N + N + card_str + N + N + shuffle_msg + N + N + deckloadpreview + N + deckpreviewtext}" -footer "{FOOTER_STRING}" -thumb "{character_pic}" """
    
    return f"""embed -title "{name} wants to select a deck!" -desc "**Deck Options and Sources:**{N + '- ' + (N + '- ').join(sourcedisplay) + N + N}To set your selected deck, please use `!deck select #` replacing `#` with the number of the Deck you would like to select." -footer "{FOOTER_STRING}" -thumb "{character_pic}" """
## """
## Use `!deck select` to select a different deck! Read the options carefully!
## """

if "init" == args[0] or "i" == args[0]:
    if len(args) >= 2:
        if "join" == args[1] and c:
            if c.me:
                init_dataset_message = ""

                if not c.get_metadata(COMBAT_DECKLOAD_NAME):
                    c.set_metadata(COMBAT_DECKLOAD_NAME, dump_yaml(deckload))
                    init_dataset_message += ("*Init deckload set to your current deckload.*"
                                             + N)

                if not (combat_drawpile := c.get_metadata(COMBAT_DRAWPILE_NAME)):
                    c.set_metadata(COMBAT_DRAWPILE_NAME, dump_json(drawpile))
                    init_dataset_message += ("*Init drawpile set to your current drawpile.*"
                                             + N)
                else:
                    drawpile = load_json(combat_drawpile)

                if not (combat_discardpile := c.get_metadata(COMBAT_DISCARDPILE_NAME)):
                    c.set_metadata(COMBAT_DISCARDPILE_NAME, dump_json(discardpile))
                    init_dataset_message += ("*Init discardpile set to your current discardpile.*"
                                             + N)
                else:
                    discardpile = load_json(combat_discardpile)

                if not (combat_exhaustpile := c.get_metadata(COMBAT_EXHAUSTPILE_NAME)):
                    c.set_metadata(COMBAT_EXHAUSTPILE_NAME, dump_json(exhaustpile))
                    init_dataset_message += ("*Init exhaustpile set to your current exhaustpile.*"
                                             + N)
                else:
                    exhaustpile = load_json(combat_exhaustpile)

                c.set_metadata(combat_hand_name, dump_json(cardhand))
                handlen = len(cardhand)
                if handlen > 0:
                    cheatmsg = f" Carried over {handlen} " + ("cards.*" if handlen != 1 else "card.*")
                else:
                    cheatmsg = "*"
                init_dataset_message += ("*Hand in init set to your current hand."
                                        + cheatmsg
                                        + N)

                if init_dataset_message:
                    init_dataset_message += N + current_cards_str(drawpile=drawpile, cardhand=cardhand, discardpile=discardpile, exhaustpile=exhaustpile)

                c.me.add_effect(
                    COMBAT_EFFECT_NAME,
                    desc=f"{name} is sharing a drawpile, discardpile, and exhaustpile with the other card players in initiative."
                )
                return f"""embed -title "{name} is now sharing cards with other creatures in initiative!" -desc "{init_dataset_message}" -f "{name}|**Effect:** {effect_preview(c.me.get_effect(COMBAT_EFFECT_NAME))}" -footer "{FOOTER_STRING}" -thumb "{character_pic}" """

            else:
                return f"""embed -title "{name} can't join the card players!" -desc "{name} isn't in initiative!" -footer "{FOOTER_STRING}" -thumb "{character_pic}" """

    ## Just shows some information about the current shared initiative.
    if c:
        card_players = [combatant.name for combatant in c.combatants if combatant.get_effect(COMBAT_EFFECT_NAME)]
        if card_players:
            card_player_msg = "`" + "`, `".join(card_players) + "`" + f"{'is' if len(card_players) == 1 else 'are'} currently sharing cards."
        else:
            card_player_msg = "There are currently no creatures sharing cards in initiative."

        combat_card_data = ""

        if (deckload := c.get_metadata(COMBAT_DECKLOAD_NAME)):
            combat_card_data += ("**Combat Deckload:**"
                                + TRIPLE_BACK_TICKS
                                + "yaml"
                                + N
                                + deckload
                                + TRIPLE_BACK_TICKS)
        else:
            combat_card_data += '**No Combat \\"deckload\\" set.**' + N + N
        
        if (combat_drawpile := c.get_metadata(COMBAT_DRAWPILE_NAME)):
            drawpile = load_json(combat_drawpile)
        else:
            drawpile = []
        
        if (combat_discardpile := c.get_metadata(COMBAT_DISCARDPILE_NAME)):
            discardpile = load_json(combat_discardpile)
        else:
            discardpile = []
        
        if (combat_exhaustpile := c.get_metadata(COMBAT_EXHAUSTPILE_NAME)):
            exhaustpile = load_json(combat_exhaustpile)
        else:
            exhaustpile = []

        combat_card_data += current_cards_str(drawpile=drawpile, cardhand=cardhand, discardpile=discardpile, exhaustpile=exhaustpile, shared=True)
        
        return f"""embed -title "{name} checks on the current shared deck!" -desc "{combat_card_data}" -footer "{FOOTER_STRING}" -thumb "{character_pic}" """

    ## Returns if there is no combat to report and there is no `!init join`
    return f"""embed -title "There's no active initiative or shared deck to check on!" -desc "Try sharing your cards by joining initiative, then using `!deck init join`!" -footer "{FOOTER_STRING}" -thumb "{character_pic}" """


## """
## Use `!deck init` to check the current state of the shared deck initiative. Characters in shared deck initiative share the same draw pile, discard pile, and exhaust pile.
## {N}Use `!deck init join` to start sharing your cards with other players! (The first character to join sets the initiative's card piles to their own.)
## """

return help_embed()
</drac2>