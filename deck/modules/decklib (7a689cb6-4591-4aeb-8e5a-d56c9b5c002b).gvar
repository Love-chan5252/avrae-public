# decklib = "7a689cb6-4591-4aeb-8e5a-d56c9b5c002b"
# 
# A module to help handle the various card-storing variables used by
#     the !deck alias. You should include this module in code run by custom
#     cards, epitomally if they deal with discarding or drawing more cards.
# 
# This module is intended to do all of the handling for the !deck alias.
#     Let's hope it actually gets there.
#
# ===== IMPORTANT =====
# 
# These functions are intended to keep your card piles intact. Without them,
#     it's going to be very inconvenient to stop cards from duplicating, disappearing,
#     saving incorrectly, and not showing up in the summary in almost every embed. (That's 
#     the one that says *XX cards remaining in draw pile* and *X cards in hand*)
#
# ===== CVARS =====
# 
# A character playing with !deck has three main card piles, each of which has a cvar:
# - drawpile:     Where cards are drawn from.
# - cardhand:     Where drawn cards are kept.
# - discardpile:  Where cards are put when discarded from the hand.
#
# A character also has two more cvars, more secretive than the last:
# - exhaustpile:  Where cards go to die. Think of it like setting a card on FIRE
#                     so you can't shuffle it back into your drawpile anymore. Only 
#                     a !deck reset can bring these cards back.
# - deckload:     a YAML dictionary of information used to access which deck the
#                     current character is actually using.
#
# Of all of these, deckload is arguably the most important. Without it, the
#     deck cannot be reset.

# -----------------
# |   CONSTANTS   |
# -----------------

COMBAT_EFFECT_NAME = "Playing Cards"
COMBAT_DECKLOAD_NAME = "init_deckload"
COMBAT_DRAWPILE_NAME = "shared_drawpile"
COMBAT_DISCARDPILE_NAME = "shared_discardpile"
COMBAT_EXHAUSTPILE_NAME = "shared_drawpile"
DEFAULT_DECKS = ["f4b75892-9488-413e-88c9-20b8183541c6"]
N = "\n"

# ---------------------------
# |   IMPORTANT VARIABLES   |
# ---------------------------

_char = character()
_current_combat = combat()

# The shared drawpile name used when use_shared_deck is True.
combat_hand_name = _char.name + "_COMBATHAND" 

# Sets the bool :use_shared_deck: to True if the current character has used
# "!deck init join" to share cards in combat. Is False otherwise.
try:
    use_shared_deck = bool(
        _current_combat.me.get_effect(COMBAT_EFFECT_NAME)
    )
except:
    use_shared_deck = False

def default_deckload():
    """
    Returns the default value of :deckload:, because it's easier to save it in a function
    until we need it than to waste time defining it.
    :return: The default value of :deckload:
    :rtype: dict
    """
    return {
        "deckname": list(
                load_json(
                get_gvar(DEFAULT_DECKS[0])
            ).keys()
        )[0],
        "gvar": DEFAULT_DECKS[0]
    }

# If not sharing cards in init, gets :deckload: from the char's personal settings.
if not use_shared_deck:
    
    # If deckload cvar is saved, use it to get :deckload:.
    if _char.get_cvar("deckload"):
        # Uses the cvar to get the saved deck info.
        deckload = load_yaml(
            _char.get_cvar(
                "deckload",
                dump_yaml(default_deckload()) # The default returned if no metadata exists.
            )
        )

    # If no deckload cvar exists, creates :deckload: using the first option in
    # :DEFAULT_DECKS:, then saves it.
    else:
        deckload = default_deckload()
        set_deckload(deckload)

# Gets :deckload: from the shared initiative settings.
else:
    deckload = load_yaml(
        _current_combat.get_metadata(
            COMBAT_DECKLOAD_NAME,
            dump_yaml(default_deckload()) # The default returned if no metadata exists.
        )
    )

# Uses :deckload: to load the deck. :deckLoaded: is basically all of the card information.
deckLoaded = (
    load_json(
        get_gvar(deckload["gvar"])
    )
)[deckload["deckname"]]

def fresh_deck():
    """
    Used for resetting the deck.
    :return: A list of all of the card keys of the loaded deck.
    :rtype: list
    """
    return list(
        deckLoaded.keys()
    )

# Loads :drawpile:, :cardhand:, :discardpile:, and :exhaustpile: according to the char's personal settings.
if not use_shared_deck:

    drawpile = load_json(
        _char.get_cvar(
            "drawpile",
            dump_json(fresh_deck())  # The default returned if no drawpile cvar exists.
        )
    )

    cardhand = load_json(
        _char.get_cvar(
            "cardhand",
            dump_json([])  # The default returned if no cardhand cvar exists.
        )
    )

    discardpile = load_json(
        _char.get_cvar(
            "discardpile",
            dump_json([])  # The default returned if no discardpile cvar exists.
        )
    )

    exhaustpile = load_json(
        _char.get_cvar(
            "exhaustpile",
            dump_json([])  # The default returned if no exhaustpile cvar exists.
        )
    )

# Loads :drawpile:, :cardhand:, :discardpile:, and :exhaustpile: from shared combat settings.
else:

    drawpile = load_json(
        _current_combat.get_metadata(
            COMBAT_DRAWPILE_NAME,
            dump_json([])  # The default returned if no metadata exists.
        )
    )

    cardhand = load_json(
        _current_combat.get_metadata(
            combat_hand_name,
            dump_json([])  # The default returned if no metadata exists.
        )
    )

    discardpile = load_json(
        _current_combat.get_metadata(
            COMBAT_DISCARDPILE_NAME,
            dump_json([])  # The default returned if no metadata exists.
        )
    )

    exhaustpile = load_json(
        _current_combat.get_metadata(
            COMBAT_EXHAUSTPILE_NAME,
            dump_json([])  # The default returned if no metadata exists.
        )
    )

# -----------------
# |   FUNCTIONS   |
# -----------------

# ===== EMBED UTILITIES =====

def get_card_display_names(cards: list):
    """
    Gets the display names of the cards from their IDs.
    :arg list cards: A list of the cards whose names you want to get, like :drawpile: or :cardhand:
    :return: A list of card display names.
    :rtype: list   
    """
    return [deckLoaded[i]["name"] for i in cards]

def generate_fields(list_: list, fieldhead: str=ZERO_SPACE, splitby: int=5, inline: bool=True):
    """
    Spluts up a list of values (usually the names of cards) and generates field strings to display them.
    :arg list list_: The list of values to split up.
    :arg str fieldhead: The name at the top of each generated field. Appears blank by default.
    :arg int splitby: The amount of items from the list to include in each field. 5 by default.
    :arg bool inline: Whether to make the fields inline. True by default.
    :return: A string containing all of the fields.
    :rtype: str
    """

    # Generate the fields only if :list_: isn't empty.
    if len(list_) > 0:

        split_lists = []

        # Generates a list of sub-lists, each with as many items as allowed by :splitby:
        for i in range((len(list_) + splitby - 1)//splitby):
            ## With default input, appends list_[0:5], then list_[5:10], list_[10:15] and so on
            split_lists.append(
                list_[i*splitby:(i + 1)*splitby]
            )

        out_fields = []

        # Generates the fields from the items in the sub-lists.
        for i in split_lists:
            out_fields.append(
                f"""-f "{fieldhead}|{N.join(i)}{'|inline' if inline else ''}" """
            )
        
        # Returns the field strings, separated by spaces, as one big string.
        return " ".join(out_fields)
    
    # Returns an empty string if :list_: is empty.
    else:
        return ""

def cutstring(inp: str, cut: int=400):
    """
    Shortens strings that are too long to fit in embeds.
    :arg str inp: The string. Only gets cut if it's too long.
    :arg int cut: How long a string can be before it gets shortened. Default 400.
    :return: The shortened string.
    :rtype: str
    """

    # Slices the string short if it's too long.
    if len(inp) > cut:
        return inp[:cut] + f"... ({len(inp[cut:])} characters remaining)"
    else:
        return inp

def effect_preview(effect: SimpleEffect):
## Prints a quick preview of an effect as shown by a char's name in init on their turn
    """
    Re-creates the text of an init effect as it appears by a character's name on their turn in combat.
    :arg SimpleEffect effect: The combat effect to create preview text for.
    :return: The text of the init effect as it appears in-combat.
    :rtype: str
    """

    return str(effect).splitlines()[:1]

def current_cards_str():
    """
    Creates the string that reports the counts of your cards in each pile.
    :return: The string reporting your current cards.
    :rtype: str
    """
    
    # Gets the number of cards in each pile to use.
    drawpilelen = len(drawpile)
    handlen = len(cardhand)
    discardlen = len(discardpile)
    exhaustlen = len(exhaustpile)

    # Needs to be defined separately becuase all of the exhaust length is in an f-string
    exhaustplural = f"{'cards' if exhaustlen != 1 else 'card'}"
    
    # Modifies to text to reflect whether the char is sharing cards in combat or not.
    sharetext = f"{' shared ' if use_shared_deck else ' '}"
    
    # Builds the string and returns it.
    return ("*"
            + drawpilelen
            + f" {'cards' if drawpilelen != 1 else 'card'} remaining in{sharetext}draw pile."
            + "*" + N + "*"
            + handlen
            + f" {'cards' if handlen != 1 else 'card'} in hand."
            + "*" + N + "*"
            + discardlen
            + f" {'cards' if discardlen != 1 else 'card'} in{sharetext}discard pile."
            + "*"
            # The exhaust string will only appear if you're a Cardistor (homebrew class) or if you have cards exhausted.
            + (f""" {N + "*" + exhaustlen + sharetext + exhaustplural + " exhausted.*" if (character().levels.get("Cardistor")>=1 or exhaustlen>0) else ""}""")
    )

# ===== DECK MANAGEMENT UTILITIES =====

def set_list(list_: list, new_contents: list) -> list:
    """
    Sets the contents of a list to the contents of a new list by transforming it.
    :arg list list_: The list to set the contents of.
    :arg list new_contents: The new contents of the list.
    :return: The list with its new contents.
    :rtype: list
    """

    # Removes all items of the original list.
    list_.clear()
    
    # Adds all the items from :new_contents: into the original list.
    list_.extend(new_contents)
    
    return list_

def match(inputs: list, match_from: list):
    """
    Fetches the keys of cards in a list from inputs matching their display names.
    Gets up to 1 non-duplicate key for each input.
    :arg list inputs: A list of strings to match against the card display names.
    :arg list match_from: The list to grab the keys from, I.E. cardhand or discardpile.
    :var dict deckLoaded: All of the card information of the deck being used.
    :return: The list of matching card keys.
    """

    # Assembles a list of tuples containing the card IDs and display names to compare the inputs to.
    key_tuples = [(subdict["name"], card_ID) for card_ID, subdict in deckLoaded.items()]

    out = []

    # Iterates over each string in :inputs:
    for substring in inputs:
        user_matching_keys = []

        # Iterates over each card display name to get each matching key.
        for display_name, card_key in key_tuples:
            if substring.lower() in display_name.lower():
                user_matching_keys.append(card_key)

        # Iterates over each matching key to make sure they're valid,
        # that they're not a duplicate, and takes only the first one.
        for i in user_matching_keys:
            if i in match_from and not i in out:
                out.append(i)
                break

    return out

def seek(cards: list, seek_from: list):
    """
    Finds and removes cards from a specified list. 
    If taking user input for cards, it's recommended to use cards=match(user_input, seek_from).
    seek() is used to create the discard() and exhaust() functions.
    :arg list cards: An exact list of the keys of the cards to look find and remove. Examples of keys can be found in the drawpile
    or discardpile cvars, and in the output of fresh_deck(). They are the same as the keys in the deck's gvar.
    :arg list seek_from: The list of cards to find and remove cards from. Usually :discardpile:, :drawpile:, or :cardhand:.
    :return: The cards that were found and removed from :seek_from:
    :rtype: list
    """

    sought = []

    # Iterates over each card in :input_card:, saves and removes them if their keys match the given input.
    for card in cards:
        # Builds a temporary list of indexes of the cards in :discard_from: that match the input currently being tested,
        # then returns the index of the first match and runs the following code if it isn't None.
        if (found := ([i for i, v in enumerate(discard_from) if card.lower() == v.lower()]+[None])[0]):
            # Saves and removes the first matching card if a match was found.
            sought.append(
                discard_from.pop(
                    found  # :found: is an int, the index of the matching card.
                )
            )

    return sought

# ===== DECK DATA STORING =====

def set_deckload(new_deckload: list):
    """
    Saves :new_deckload: in the __ cvar or in the init metadata if the char has done !deck init join.
    WARNING: You usually do not want to modify the deckload cvar. An invalid deckload is the easiest way to break the alias.
    :arg list new_deckload: The new list to put into the deckload.
    :var bool use_shared_deck: Determines where to save :new_deckload:.
    """

    # Saves :new_deckload: to combat metadata if :use_shared_deck: is True, and saves it to the cvar otherwise.
    if not use_shared_deck:
        _char.set_cvar("deckload",dump_yaml(new_deckload))
    else:
        _current_combat.set_metadata(COMBAT_DECKLOAD_NAME, dump_yaml(new_deckload))

def set_drawpile(new_drawpile: list):
    """
    Saves :new_drawpile: in the drawpile cvar or in the init metadata if the char has done !deck init join
    :arg list new_drawpile: The new list to put into the drawpile 
    :var bool use_shared_deck: Determines where to save :new_drawpile:
    """

    # Saves :new_drawpile: to combat metadata if :use_shared_deck: is True, and saves it to the cvar otherwise.
    if not use_shared_deck:
        _char.set_cvar("drawpile", dump_json(new_drawpile))
    else:
        _current_combat.set_metadata(COMBAT_DRAWPILE_NAME, dump_json(new_drawpile))

def set_cardhand(new_hand: list):
    """
    Saves :new_hand: in the cardhand cvar or in the init metadata if the char has done !deck init join
    :arg list new_hand: The new list to put into the cardhand 
    :var bool use_shared_deck: Determines where to save :new_hand:
    """

    # Saves :new_hand: to combat metadata if :use_shared_deck: is True, and saves it to the cvar otherwise.
    if not use_shared_deck:
        _char.set_cvar("cardhand", dump_json(new_hand))
    else:
        _current_combat.set_metadata(combat_hand_name, dump_json(new_hand))

def set_discardpile(new_discardpile: list):
    """
    Saves :new_discardpile: in the discardpile cvar or in the init metadata if the char has done !deck init join
    :arg list new_discardpile: The new list to put into the discardpile 
    :var bool use_shared_deck: Determines where to save :new_discardpile:
    """

    # Saves :new_discardpile: to combat metadata if :use_shared_deck: is True, and saves it to the cvar otherwise.
    if not use_shared_deck:
        _char.set_cvar("discardpile", dump_json(new_discardpile))
    else:
        _current_combat.set_metadata(COMBAT_DISCARDPILE_NAME, dump_json(new_discardpile))

def set_exhaustpile(new_exhaustpile):
    """
    Saves :new_exhaustpile: in the exhaustpile cvar or in the init metadata if the char has done !deck init join
    :arg list new_exhaustpile: The new list to put into the exhaustpile.
    :var bool use_shared_deck: Determines where to save :new_exhaustpile:
    """

    # Saves :new_exhaustpile: to combat metadata if :use_shared_deck: is True, and saves it to the cvar otherwise.
    if not use_shared_deck:
        _char.set_cvar("exhaustpile", dump_json(new_exhaustpile))
    else:
        _current_combat.set_metadata(COMBAT_EXHAUSTPILE_NAME, dump_json(new_exhaustpile))

def reset_deck():
    if autoshuffle_on_reset:
        reset_pile = shuffle(fresh_deck())
        set_drawpile(reset_pile)
    else:
        reset_pile = fresh_deck()
        set_drawpile(reset_pile)

    set_cardhand([])
    set_discardpile([])
    set_exhaustpile([])

    for i in range(len(cardhand)):
        cardhand.pop(0)
    for i in range(len(discardpile)):
        discardpile.pop(0)
    for i in range(len(exhaustpile)):
        exhaustpile.pop(0)

    return reset_pile

def reset_deck():
    """
    Resets :drawpile: to the deck's base cards, clears :cardhand:, :discardpile:, and :exhaustpile:,
    then saves the deck info to the cvars or metadata to reflect those changes.
    :return: The new drawpile's contents.
    :rtype: list
    """

    # Puts the base deck's cards into :drawpile: and saves it in the drawpile cvar or metadata.
    set_list(drawpile, fresh_deck())
    set_drawpile(drawpile)

    # Empties :cardhand: then saves it in the cardhand cvar or metadata.
    cardhand.clear()
    set_cardhand([])

    # Empties :discardpile: then saves it in the discardpile cvar or metadata.
    discardpile.clear()
    set_discardpile([])
    
    # Empties :exhaustpile: then saves it in the exhaustpile cvar or metadata.
    exhaustpile.clear()
    set_exhaustpile([])    

    return drawpile


# ===== DECK MANIPULATION =====

def shuffle(cards: list):
    """
    Shuffles the cards in a list into a random order.
    :arg list cards: The list of cards to be shuffled.
    :return: The shuffled list of cards.
    :rtype: list
    """

    shuffled = []

    # Puts all of the cards, randomly reordered, into :shuffled:.
    for _ in range(len(cards)):
        shuffled.append(
            cards.pop(
                randint(0, len(cards))
            )
        )
    
    # Saves the shuffled cards back into the inputted list, so the same list has the new contents.
    set_list(cards, shuffled)

    return cards

def draw(draw_from: list, drawnum: int=1):
    """
    Draws (and removes) cards from the beginning of a list and puts them into your hand.
    :arg list draw_from: The list to draw the cards from.
    :arg int drawnum: The number of cards to draw. You cannot draw more cards than are inside the list.
    :return: A list of the drawn cards.
    :rtype: list
    """

    # Makes sure that not too many cards are drawn.
    drawnum = min(
        max(1, drawnum),
        len(draw_from)
    )

    drawn = []
    
    # Draws the cards and puts them into drawn.
    for _ in range(drawnum):
        drawn.append(
            draw_from.pop(0)
        )

    # Adds the drawn cards to :cardhand:.
    cardhand.extend(drawn)

    # Saves :cardhand: in the cvar or combat metadata.
    set_cardhand(cardhand)

    return drawn

def discard(cards: list, discard_from: list):
    """
    Removes cards from a list and adds them to the discard pile.
    If taking user input for cards, it's recommended to use cards=match(user_input, discard_from)
    :arg list cards: An exact list of the keys of the cards to discard. Look in the docstring for seek() for more about card keys.
    :arg list discard_from: The list of card keys to discard from. Usually :cardhand:.
    :return: A list of the discarded cards.
    :rtype: list
    """

    # Finds and removes the matching cards in :cards: from :discard_from:.
    discarded = seek(cards, discard_from)

    # Adds the discarded cards to :discardpile: 
    discardpile.extend(discarded)

    # Saves :discardpile: in the cvar or combat metadata.
    set_discardpile(discardpile)

    return discarded

def exhaust(cards: list, exhaust_from: list):
    """
    Removes cards from a list and adds them to the exhaust pile.
    If taking user input for cards, it's recommended to use cards=match(user_input, exhaust_from)
    :arg list cards: An exact list of the keys of the cards to exhaust. Look in the docstring for seek() for more about card keys.
    :arg list exhaust_from: The list of card keys to exhaust from. Usually :cardhand:.
    :return: A list of the exhausted cards.
    :rtype: list
    """

    # Finds and removes the matching cards in :cards: from :exhaust_from:.
    exhausted = seek(cards, exhaust_from)

    # Adds the exhausted cards to :exhaustpile: 
    exhaustpile.extend(exhausted)

    # Saves :exhaustpile: in the cvar or combat metadata.
    set_exhaustpile(exhaustpile)

    return exhausted


